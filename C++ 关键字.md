# C++ 关键字

**asm(指令字符串)**: 

- 允许在C++程序中嵌入汇编代码

**else**: 

- else紧跟在if后面，用于对if不成立情况的选择

**new**:

- 用于新建一个对象。new运算符总是返回一个指针。由new创建

**this**：

- this返回调用者本身的指针

**auto**:

- (自动，automatic), 是存储类型标识符，表明变量 "自动"，具有本地范围，块范围的变量声明(如for循环内的变量声明)默认为auto存储类型

**enum**:

- 枚举类型，给出一系列固定值，只能在这里面选一个

**operator**:

- 用于操作符重载。这时C++的一种特殊的函数

**throw**:

- 抛出异常，用于实现在C++的异常处理机制，可以通过throw关键字抛出一个异常

**bool**:

- 布尔类型，C++中的基本数据结构，其值可选为True(真)或者False(假)。C++种的bool类型可以和int混用，具体来说就是0代表false，非0代表true。bool类型常用于条件判断和函数返回值

**explicit**:

- Explicit(显示的)的作用是 “禁止单参数构造函数”被用于自动类型转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中可以将初始化长度作为参数传递给构造函数

**private**:

- 私有的，C++中访的访问控制符。被标明为private的字段只能在本类以及友元中访问

**true**:

- True(真的)，C++的基本数据结构bool的类型之一。等同于int的非0值

**break**:

- 中断，跳出。用于在switch语句或者循环语句中。程序遇到break后，即跳出该程序段，继续后面的语句执行

**export**:

- 为了访问其他编译单元(如另一个代码文件)中的变量或者对象，对普通类型(包括基本数据类、结构和类)，可以用extern，来使用这些变量或对象时；但是对模板类型，则必须在定义这些模板类对对象和模板函数时，使用高标准C++新增加的关键字export(导出)

**protected**:

- 受保护的，C++中的访问控制符。被标明为protected的字段只能在本类以及其继承类和友元中访问

**try**:

- try(尝试)，用于实现C++的异常处理机制。可以在try中调用可能抛出异常的函数，然后在try后面的catch中捕获并处理

**case**:

- 用于switch语句中，用于判断不同的条件类型

**extern**:

- extern(外部的)声明变量或函数因为外部链接，即该变量或函数名在其他文中可见。被其修饰的变量(外部变量)是静态分配空间的，即程序开始时分配，结束时释放。用于其声明的变量或函数应在别的文件或同一文件的其它地方定义(实现)。在文件内声明一个变量或函数默认为可被外部使用。在C++中，还可用啦指定该使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持C转换标记，来支持C编译器连接。

**public**:

- 公有的，C++中的访问控制符。被标记为public的字段可以在任何类中使用

**catch**:

- catch和try语句一起用于异常处理

**false**:

- False(假的)，C++的基本数据结构bool类型的值之一。等同于int的0值

**register**:

- register(寄存器)声明的变量称为寄存器变量，在可能得情况下会直接存放在机器的寄存器中；但对32位编译不起作用，当global optimizations(全局优化)开的时候，它会做出选择是否放在自己的寄存器中；不过其他与register关键字有关的其他运算符都对32位编译器有效

**typeid**:

- 指出指针或引用指向的对象的实际派生类型

**char**:

- char(字符, character)类型，C++中的基本数据结构，其值一般为0~255的int。这255个字符对应着256个ASCII码，char类型的数据需要用单引号括起来

**float**:

- Float(浮点数)，c++中的基本数据结构，精度小于double

**reinterpret_cast**:

- type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值)

**typename**:

- typename(类型名字)，关键字告诉编译器把一个特殊的名字解释称类。在下列情况下必须对一个name使用typename关键字:
  - 1、一个唯一name(可以作为类型理解)，它嵌套在另一个类型中
  - 2、依赖于一个模板函数，就是说，模板参数在某种程度上包含了这个name。当模板参数使用编译器在指认一个类型时产生了误解

**class**:

- 类，是C++面向对象设计的基础。使用class关键字声明一个类。

**for**:

- for是C++的循环结构之一

**return**:

- 返回，用于在函数的返回值中。程序在执行到return语句后立即返回，return后面的语句无法执行

**union**:

- union(联合)，类似于enum。不同的是enum实质上是int类型的，而unin可以用于所有类型，并且其占用空间是随着实际类型大小变化的

**const**:

- const(常量的, constant)所修饰的对象或变量不能改变，修饰函数时，该函数不能改变在该函数外声明的变量，也不能调用任何非const函数。在函数的声明与定义时都要加上const，放在函数参数列表的最后一个括号后。在C++中，用const声明的一个变量意味着该变量就是一个带类型的常量，可以代替#define，且比#define多一个类型信息，且它执行内连接，可放在头文件中声明；但是在C中，其声明则必须放在源文件(即.c文件)中，在C中const声明一个变量，除了不能改变其值外，它扔是一具变量。

**friend**:

- friend(友元)声明友元关系。友元可以访问与其有friend关系的类中的private/protected成员，通过友元直接访问类中的private/protected成员的主要目的是提高效率。友元包括友元函数和友元类

**short**:

- short(短整数, short intger)，C++中的基本数据结构，用于表示整数，精度小于int

**unsigned**:

- unsigned(无符号)，表名该类型时无符号的，和signed相反

**const_cast**:

- 该运算符用来修改类型的const或volatile属性。除了const或volatile修饰之外，type_id和expression的类型是一样的。产量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转成非常量引用，并且仍然指向原来的对象；常量对象被转成非产量对象

**goto**:

- 跳转，用于无条件跳转到某一标记处开始执行

**signed**:

- singed(有符号)，表明该类型时有符号数，和unsigned相反。数字类型(整形和浮点型)都可以用signed修饰。但默认就是signed，所以一般不会显示使用

**using**:

- 表明使用namespace

**continue**:

- Continue(继续)关键字用于循环结构。它使程序跳过代码段后面的部分，与break不同的是，continue不是进入代码段后的部分执行，而是重新开始新的循环。因而它是“继续循环”之意，不是break

**if**:

- 如果，C++中的条件判断语句之一，可以根据后面的bool类型的值选择进入要给分支执行

**sizeof**:

- 由于C++每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用sizeof运算符获得该数据类型占用的字节数

**virtual**:

- virtual(虚的)，C++中用来实现多态机制

**default**:

- default(默认、缺省)用于swtich语句。当switch所有的case都不满足时，将进入default执行。default只能放在switch语句所有case之后，并且是可选的。

**inline**:

- 内联，内联函数的定义将在编译时在调用处展开。inline函数一般由短小的语句组成，可以提高程序效率

**static**:

- Static(静态的)，静态变量作用范围在一个文件内，程序开始时分配空间，结束是释放空间，默认初始化为0，使用时可以改变其值。静态变量或静态函数，只有本文件内的代码才可访问。它的名字(变量名或函数名)在其他文件中不可见。因此也称为"文件作用域"。在C++类的成员变量声明为static(称为静态成员变量)；意味着它被该类的所有实例共享，也就是说当某个类的实例修改了改静态成员变量，其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员(变量或函数)。类的静态成员变量必须在声明它的文件范围内进行初始化才能使用，private类型的也不例外

**void**:

- void(空的)，可以作为函数返回值，表明不返回任何数据；可以作为参数，表明没有任何参数传入(C++中不是必须的)；可以作为指针使用

**delete**:

- delete(删除)，释放程序动态申请内存空间。delete后面通常是一个指针或者数组[]，并且只能delete通过new关键字申请的指针，否者会发生错误

**int**:

- (整形，interger)，C++中的基本数据结构，用于表示整数，精度小于long

**static_cast**:

- 该运算符把expression转换为type_id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法:

  - 用于类层次结构中基类和子类之间指针或引用的转换。记性上行转换(把子类的指针或引用转换成基类表示)是安全的；进行下行转换(把基类指针或引用转换成子类表示)时，由于没有动态类型检查，所以是不安全的。
  - 用于基类数据类型之间转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证
  - 把控指针转换成目标类型的空指针
  - 把任何类型的表达式转换成void类型

  注意: static_cast不能转换掉experession和 const、volitatle、或者_unaligned属性

**volatile**:

- volatile(不稳定的)限定一个对象可被外部进程(操作系统、硬件或并发线程)改变，声明时的语法为: int volatile nVint。 这样声明是不能达到高效的，因为他们的值随时会改变，系统在需要时会经常读写这个对象的值，因此常用于像中断处理程序之类的一部进程内存单元。

**do**:

- do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环一次

**long**:

- (长整形, long interger)，C++中的基本数据结构，用于表示长整型

**struct**:

- struct(结构)类型，类似于class关键字，与C语言兼容(class关键字是不与C语言兼容的)，可以实现面向对象的程序设计

**wchar_t**:

- 宽字符类型，每个wchar_t类型占2个字节，16为宽。汉字的表示就要用到wchar_t

**double**:

- double(双精度)类型，C++中的基本数据结构，以双精度形式存储一个浮点数

**mutable**:

- 易变的 mutable是C++中一个不常用的关键字。只能用于类的非静态和非常量数成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对象的状态也会随之发生改变。如果一个类的成员函数被声明为const类型，表示该函数不糊改变对象状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该函数中对类的数据成员进行赋值，这个时候就需要用到mutable关键字

**switch**:

- switch(转换)类似于if-else-if 语句，是一种多分支语句。它提供了一种简介的书写，并且能够生成效率更好的代码。但是，switch后面的判断只能用int(char也可以，但char本质上也是一种int类型)。switch语句最后的default分支是可选的

**while**:

- C++的一种循环结构之一，表示一种入口条件循环

**dynamic_cast**:

- dynamic_cast(动态转换)，允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全的转换类型。dynamic_cast提供了两种转换形式，把基类指针转换成派生类指针，或者把指向基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用

**namespace**:

- 命名空间用于在逻辑上组织类，是一种比类大的结构

**template**:

- 模板，C++中泛型机制的实现

